/** * Sheet-to-Form Automator - Enhanced Content Script * Handles DOM manipulation and form filling with multiple selector types */ class FormFiller {constructor() {this.successCount=0;this.errorCount=0;this.totalCount=0;this.errors=[];} /** * Main form filling function */ async fillForm(formData) {console.log('üöÄ Starting form fill process with',formData.length,'fields');this.successCount=0;this.errorCount=0;this.totalCount=formData.length;this.errors=[];// Process each form field for (let i=0;i < formData.length;i++) {const fieldData=formData[i];console.log(`üìù Processing field ${i + 1}/${formData.length}:`,fieldData.fieldName);try {await this.processField(fieldData);this.successCount++;console.log(`‚úÖ Successfully processed: ${fieldData.fieldName}`);} catch (error) {this.errorCount++;const errorInfo={fieldName: fieldData.fieldName,selector: fieldData.selector,selectorType: fieldData.selectorType,error: error.message};this.errors.push(errorInfo);console.error(`‚ùå Error processing ${fieldData.fieldName}:`,error.message);} // Small delay between fields to prevent overwhelming the page await this.sleep(50);} // Log summary console.log(`üìä Form fill completed: ${this.successCount}/${this.totalCount} successful`);if (this.errors.length > 0) {console.log('‚ùå Errors encountered:',this.errors);} return {success: true,successCount: this.successCount,errorCount: this.errorCount,totalCount: this.totalCount,errors: this.errors};} /** * Process a single form field */ async processField(fieldData) {const {fieldName,selector,selectorType,value}=fieldData;// Find the element const element=await this.findElement(selector,selectorType);if (!element) {throw new Error(`Element not found with selector: ${selector} (type: ${selectorType})`);} // Scroll element into view element.scrollIntoView({behavior: 'smooth',block: 'center'});await this.sleep(100);// Perform the action based on value type await this.performAction(element,value,fieldName);} /** * Enhanced element finder with multiple selector types */ async findElement(selector,selectorType) {const type=selectorType.toLowerCase().trim();let element=null;try {switch (type) {case 'css':case 'selector':element=await this.findByCss(selector);break;case 'xpath':case 'path':element=await this.findByXPath(selector);break;case 'id':element=await this.findById(selector);break;case 'name':element=await this.findByName(selector);break;case 'class':case 'classname':element=await this.findByClassName(selector);break;case 'tag':case 'tagname':element=await this.findByTagName(selector);break;case 'text':case 'linktext':element=await this.findByText(selector);break;case 'partialtext':case 'partial':element=await this.findByPartialText(selector);break;case 'placeholder':element=await this.findByPlaceholder(selector);break;case 'title':element=await this.findByTitle(selector);break;case 'value':element=await this.findByValue(selector);break;case 'type':element=await this.findByType(selector);break;case 'label':element=await this.findByLabel(selector);break;case 'alt':element=await this.findByAlt(selector);break;case 'role':element=await this.findByRole(selector);break;case 'data':case 'attribute':element=await this.findByDataAttribute(selector);break;case 'auto':case 'smart':element=await this.findElementSmart(selector);break;default:throw new Error(`Unsupported selector type: ${selectorType}. Supported types: css, xpath, id, name, class, tag, text, partialtext, placeholder, title, value, type, label, alt, role, data, auto`);}} catch (error) {console.error(`Error with ${type} selector "${selector}":`,error.message);throw error;} return element;} /** * Find by CSS selector */ async findByCss(selector) {let element=document.querySelector(selector);if (!element) {element=await this.findInIframes(selector,'css');} return element;} /** * Find by XPath */ async findByXPath(selector) {let element=null;try {const result=document.evaluate( selector,document,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null );element=result.singleNodeValue;if (!element) {element=await this.findInIframes(selector,'xpath');}} catch (error) {throw new Error(`Invalid XPath: ${error.message}`);} return element;} /** * Find by ID */ async findById(id) {const cleanId=id.replace(/^#/,'');// Remove # if present let element=document.getElementById(cleanId);if (!element) {element=await this.findInIframes(`#${cleanId}`,'css');} return element;} /** * Find by name attribute */ async findByName(name) {let element=document.querySelector(`[name="${name}"]`);if (!element) {element=await this.findInIframes(`[name="${name}"]`,'css');} return element;} /** * Find by class name */ async findByClassName(className) {const cleanClass=className.replace(/^\./,'');// Remove . if present let element=document.querySelector(`.${cleanClass}`);if (!element) {element=await this.findInIframes(`.${cleanClass}`,'css');} return element;} /** * Find by tag name */ async findByTagName(tagName) {let element=document.querySelector(tagName.toLowerCase());if (!element) {element=await this.findInIframes(tagName.toLowerCase(),'css');} return element;} /** * Find by exact text content */ async findByText(text) {const xpath=`//*[text()="${text}"]`;return await this.findByXPath(xpath);} /** * Find by partial text content */ async findByPartialText(partialText) {const xpath=`//*[contains(text(),"${partialText}")]`;return await this.findByXPath(xpath);} /** * Find by placeholder attribute */ async findByPlaceholder(placeholder) {let element=document.querySelector(`[placeholder="${placeholder}"]`);if (!element) {element=await this.findInIframes(`[placeholder="${placeholder}"]`,'css');} return element;} /** * Find by title attribute */ async findByTitle(title) {let element=document.querySelector(`[title="${title}"]`);if (!element) {element=await this.findInIframes(`[title="${title}"]`,'css');} return element;} /** * Find by value attribute */ async findByValue(value) {let element=document.querySelector(`[value="${value}"]`);if (!element) {element=await this.findInIframes(`[value="${value}"]`,'css');} return element;} /** * Find by input type */ async findByType(type) {let element=document.querySelector(`input[type="${type}"]`);if (!element) {element=await this.findInIframes(`input[type="${type}"]`,'css');} return element;} /** * Find by associated label text */ async findByLabel(labelText) {// Try to find label first const labels=document.querySelectorAll('label');for (const label of labels) {if (label.textContent.trim()===labelText) {// Get associated input const forAttr=label.getAttribute('for');if (forAttr) {return document.getElementById(forAttr);} // Check if input is nested inside label const nestedInput=label.querySelector('input, select, textarea');if (nestedInput) {return nestedInput;}}} // Fallback: find input by aria-label let element=document.querySelector(`[aria-label="${labelText}"]`);if (!element) {element=await this.findInIframes(`[aria-label="${labelText}"]`,'css');} return element;} /** * Find by alt attribute (for images) */ async findByAlt(altText) {let element=document.querySelector(`[alt="${altText}"]`);if (!element) {element=await this.findInIframes(`[alt="${altText}"]`,'css');} return element;} /** * Find by role attribute */ async findByRole(role) {let element=document.querySelector(`[role="${role}"]`);if (!element) {element=await this.findInIframes(`[role="${role}"]`,'css');} return element;} /** * Find by data attribute (format: data-attribute=value) */ async findByDataAttribute(selector) {// Parse data attribute selector // Format: "data-testid=login-button" or just "data-testid" const parts=selector.split('=');let cssSelector;if (parts.length===2) {const [attr,value]=parts;cssSelector=`[${attr}="${value}"]`;} else {cssSelector=`[${selector}]`;} let element=document.querySelector(cssSelector);if (!element) {element=await this.findInIframes(cssSelector,'css');} return element;} /** * Smart finder - tries multiple strategies */ async findElementSmart(query) {console.log(`üß† Smart finding element with query: "${query}"`);const strategies=[ // Try as ID first ()=> this.findById(query),// Try as CSS selector ()=> this.findByCss(query),// Try as class name ()=> this.findByClassName(query),// Try as name attribute ()=> this.findByName(query),// Try as placeholder ()=> this.findByPlaceholder(query),// Try as exact text ()=> this.findByText(query),// Try as partial text ()=> this.findByPartialText(query),// Try as title ()=> this.findByTitle(query),// Try as label ()=> this.findByLabel(query),// Try as data attribute ()=> this.findByDataAttribute(`data-testid=${query}`),()=> this.findByDataAttribute(`data-test=${query}`),()=> this.findByDataAttribute(`data-cy=${query}`),()=> this.findByDataAttribute(`data-qa=${query}`),// Try as aria-label ()=> this.findByCss(`[aria-label*="${query}"]`),// Try as type ()=> this.findByType(query) ];for (const strategy of strategies) {try {const element=await strategy();if (element) {console.log(`‚úÖ Smart finder found element using strategy`);return element;}} catch (error) {// Continue to next strategy continue;}} return null;} /** * Search for element in iframes */ async findInIframes(selector,selectorType) {const iframes=document.querySelectorAll('iframe');for (const iframe of iframes) {try {const iframeDoc=iframe.contentDocument || iframe.contentWindow.document;if (!iframeDoc) continue;let element=null;if (selectorType==='css') {element=iframeDoc.querySelector(selector);} else if (selectorType==='xpath') {const result=iframeDoc.evaluate( selector,iframeDoc,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null );element=result.singleNodeValue;} if (element) {console.log(`üîç Found element in iframe:`,iframe.src || iframe.id || 'unnamed iframe');return element;}} catch (error) {console.log('‚ö†Ô∏è Could not access iframe:',error.message);}} return null;} /** * Perform action on element based on value */ async performAction(element,value,fieldName) {const upperValue=value.toUpperCase();if (upperValue==='CLICK') {await this.clickElement(element);console.log(`üñ±Ô∏è Clicked: ${fieldName}`);} else if (upperValue==='CHECK') {if (element.type==='checkbox' || element.type==='radio') {if (!element.checked) {await this.clickElement(element);console.log(`‚òëÔ∏è Checked: ${fieldName}`);}} else {throw new Error('CHECK action can only be used on checkbox or radio elements');}} else if (upperValue==='UNCHECK') {if (element.type==='checkbox' || element.type==='radio') {if (element.checked) {await this.clickElement(element);console.log(`‚òê Unchecked: ${fieldName}`);}} else {throw new Error('UNCHECK action can only be used on checkbox or radio elements');}} else if (upperValue==='CLEAR') {await this.clearElement(element);console.log(`üóëÔ∏è Cleared: ${fieldName}`);} else if (upperValue==='FOCUS') {element.focus();console.log(`üéØ Focused: ${fieldName}`);} else if (upperValue==='SUBMIT') {if (element.tagName==='FORM') {element.submit();} else {// Try to find parent form const form=element.closest('form');if (form) {form.submit();} else {throw new Error('SUBMIT action requires a form element');}} console.log(`üì§ Submitted form: ${fieldName}`);} else {await this.setValue(element,value);console.log(`üìù Set value "${value}" for: ${fieldName}`);}} /** * Click an element with proper event handling */ async clickElement(element) {element.focus();const mouseEvents=['mousedown','mouseup','click'];for (const eventType of mouseEvents) {const event=new MouseEvent(eventType,{bubbles: true,cancelable: true,view: window});element.dispatchEvent(event);} await this.sleep(100);} /** * Set value on an element with proper event handling */ async setValue(element,value) {element.focus();if (element.tagName==='SELECT') {element.value=value;this.dispatchChangeEvents(element);} else if (element.type==='file') {throw new Error('File input fields cannot be filled programmatically');} else {// Clear and set value await this.clearElement(element);element.value=value;this.dispatchInputEvents(element);} await this.sleep(50);} /** * Clear element value */ async clearElement(element) {element.focus();element.value='';// Trigger events this.dispatchInputEvents(element);} /** * Dispatch input events for text inputs */ dispatchInputEvents(element) {const events=[ new Event('input',{bubbles: true}),new Event('change',{bubbles: true}),new KeyboardEvent('keyup',{bubbles: true}) ];events.forEach(event=> element.dispatchEvent(event));} /** * Dispatch change events for select elements */ dispatchChangeEvents(element) {const events=[ new Event('change',{bubbles: true}),new Event('input',{bubbles: true}) ];events.forEach(event=> element.dispatchEvent(event));} /** * Sleep function for delays */ sleep(ms) {return new Promise(resolve=> setTimeout(resolve,ms));}} // Global form filler instance const formFiller=new FormFiller();// Listen for messages from popup chrome.runtime.onMessage.addListener((request,sender,sendResponse)=> {if (request.action==='fillForm') {console.log('üì® Received form fill request');formFiller.fillForm(request.data) .then(result=> {console.log('‚úÖ Form fill completed,sending response');sendResponse(result);}) .catch(error=> {console.error('‚ùå Form fill failed:',error);sendResponse({success: false,error: error.message});});return true;} else if (request.action==='findElement') {// Helper function to test selectors console.log('üîç Testing element selector:',request);formFiller.findElement(request.selector,request.selectorType) .then(element=> {sendResponse({success: true,found: !!element,elementInfo: element ? {tagName: element.tagName,id: element.id,className: element.className,textContent: element.textContent?.substring(0,100)} : null});}) .catch(error=> {sendResponse({success: false,error: error.message});});return true;}});console.log('üîß Enhanced Sheet-to-Form Automator content script loaded');